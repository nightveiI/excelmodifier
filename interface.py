# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'interface.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox
import sys
import json
import xlwings as xw
import os

# we import our settings
with open('config.json') as config:
    settings = json.load(config)

# we import the settings from the json file to see what indexes we need from the selected CSV files
indexes = ["Project ID", "Number Alt", "Project Name", "Building Name", "Building Address", "Building City", "Building State", "Building Zip", "Assigned To", "Type", "Subtype", "Status", "Status Date", "Who Created", "Date Created", "Modified", "Who Modified", "Bid Amount",  "Original Contract Amount", "Revised Contract Amount", "Outstanding Contract Amount", "Gross Profit Margin %", "Notes", "Actual Project Cost", "Actual Project Cost Who", "Actual Project Cost Date", "Source", "Budget Amount", "Budget Notes", "Budget Dates", "Contract With Object", "Contract With Name", "Contract With Office Name", "Salesperson Name",
           "Contract Terms", "Contract Term Notes", "Division", "Reference", "Subsource", "Client PO Number", "Local Union", "Construction Capacity", "Exclusions", "Special Instructions", "Contract Date", "Hide Daily Work Crew", "Running Notes", "Reference Notes", "Serial Number", "Production Status", "Contract Status", "Contract Status Date Open", "Contract Status Date Completed", "Contract Status Date Closed", "Contract Status Who Open", "Contract Status Who Completed", "Contract Status Who Closed", "Production Status Date", "Status Who", "Production Status Who", "Contact Name", "Contact Phone Number", "Contact Email"]


# for convience, we seperate what we are able to make into dividing sheets and we use for everything else so the excel sheet doesn't get too messy
# I have reduced the categories of sheets we can make into these following ones that provide some sort of purpose when making the excel sheet
dividingIndexes = ["Building City",
                   "Building State",
                   "Building Zip",
                   "Assigned To",
                   "Type",
                   "Subtype",
                   "Status",
                   "Who Created",
                   "Modified",
                   "Who Modified",
                   "Actual Project Cost Who",
                   "Source",
                   "Salesperson Name",
                   "Division",
                   "Production Status",
                   "Contract Status",
                   "Contract Status Who Open",
                   "Contract Status Who Completed",
                   "Contract Status Who Closed",
                   "Status Who"]

# this holds our selected csv file to be converted
selectedFile = ""

def lastRow(idx, workbook, col=1):
    """ Find the last row in the worksheet that contains data.

    idx: Specifies the worksheet to select. Starts counting from zero.

    workbook: Specifies the workbook

    col: The column in which to look for the last cell containing data.
    """

    ws = workbook.sheets[idx]

    lwr_r_cell = ws.cells.last_cell      # lower right cell
    lwr_row = lwr_r_cell.row             # row of the lower right cell
    lwr_cell = ws.range((lwr_row, col))  # change to your specified column

    if lwr_cell.value is None:
        # go up untill you hit a non-empty cell
        lwr_cell = lwr_cell.end('up')

    return lwr_cell.row


#this following function is used to convert the selected dataforma file into the modified version 
#to the specifications of the user settings
def convert(file, selectedSettings, listofActions):
    xw.App(visible=False)


    # we open the workbook we are going to be using

    newWB = xw.Book()
    file.replace(".csv", ".xlsx")
    dfWB = xw.Book(file)

    # we declare variables that will be used in the loop concerning each of our setting categories
    # all but converting settings are singular variables due to converting settigns holding multiple 
    # values of what the user wants to be displayed on each sheet of the excel file
    sortingSettings = None
    dividingSettings = None
    orderSettings = None
    convertingSettings = []

    #we update the user of our status 
    listofActions.addItem("Receiving Settings Preferences")
    QtCore.QCoreApplication.processEvents() 
    #since subtype is a special case that requires preset words and the excel cells don't contain just "shingles" "metal" etc, we have to set a boolean that lets us know when to use subtypes
    #so we are able to scan the cells for those specific words rather when it's anything else, we can easily divide the categories just by the unique presence of what is in a prespective cell 
    #such as repeating salespeople names, or repeating building cities
    isSubtype = False

    #here we go through the declared indexes of all that would be av aiable to the dataforma export and check when we find a match with the user settings
    #then set the variables we declared earlier to the index of the found setting
    for i in range(len(indexes)):
        if(selectedSettings["Sorting Settings"][0][indexes[i]]):
            sortingSettings = i
        #all except the converting settings where we append all the different values they want shown into a list/array
        if(selectedSettings["Convert Settings"][0][indexes[i]]):
            convertingSettings.append(i)

    #for the dividing sheets, we iterate through this specific array and find by what variable do they want their sheets to appear, and in an example case being subtype where they want
    #metal shingles tpo and coatings in seperate sheets
    #we set the condition that if the user wants subtype, we just switch the boolean and that would be it
    #but if it's anything else, we set that prespective string on the index to the dividing settings to find the column where those words are
    for i in range(len(dividingIndexes)):
        if(selectedSettings["Divide Settings"][0][dividingIndexes[i]]):
            dividingSettings = dividingIndexes[i]
            if(dividingIndexes[i] == "Subtype"):
                isSubtype = True
                break 
    
    #we need to find the actual index in the original index array where all the other values are stored due to those being the actual positions of the values in the excel sheet
    #and dividing indexes being a shortened version that holds what we want as our dividing factor
    dividingIndex = indexes.index(dividingSettings)

    #we retrieve if our user in want order do they want the values displayed in ascending or descending order
    if(selectedSettings["Order Settings"][0]["Ascending"] == True):
        orderSettings = "ascending"
    else:
        orderSettings = "descending"

    #we update the user of our status
    listofActions.addItem("Receiving Data from Selected File")
    QtCore.QCoreApplication.processEvents() 
    #we copy over the excel sheet values into an array
    originalArray = dfWB.sheets[0].range(
        (1, 1), (lastRow(0, dfWB), len(indexes))).value
    
    #we create a new array that will hold the values we want to display
    modifiedArray = []

    #we update the user of our status where we are going through the original array and sorting the values by what value we want them to show
    listofActions.addItem("Sorting Data in " + orderSettings + " order")
    QtCore.QCoreApplication.processEvents() 
    #depending if they want ascending or descending, we sort accordingly
    #we skip the index[0] because those are the headers
    for i in range(1, len(originalArray)):
        for j in range(1, len(originalArray)):
            if(orderSettings == "ascending"):
                if(originalArray[i][sortingSettings] < originalArray[j][sortingSettings]):
                    originalArray[i], originalArray[j] = originalArray[j], originalArray[i]
            else:
                if(originalArray[i][sortingSettings] > originalArray[j][sortingSettings]):
                    originalArray[i], originalArray[j] = originalArray[j], originalArray[i]
    
    #we update the user of our status
    listofActions.addItem("Receiving what sheets to divide by")  

    #we create a new array that will hold the name of what we want our sheets to be in the file           
    dividingCategories = []
    #if we triggered the subtype boolean earlier, we can instantly just set the array to these following four strings that will be used to divide the data
    if(isSubtype):
        dividingCategories = ["Shingle", "Metal", "TPO", "Coating"]
    #if we didn't trigger the subtype boolean earlier, we have to go through the original array and find the unique values in the column we want to divide by
    else:
        for i in range(1, len(originalArray)):
            stringFound = originalArray[i][dividingIndex].upper()
            if(stringFound not in dividingCategories):
                dividingCategories.append(stringFound)
    
    #we iterate through our dividing categories and insert them into the new worksheet as independent sheets
    for i in range(len(dividingCategories)):
        #due to the addition nature of sheets via xlwings, we start from the end of the array and iterate down
        if(i == 0):
            newWB.sheets[0].name = dividingCategories[len(dividingCategories) - 1]
        else:
            newWB.sheets.add(dividingCategories[len(dividingCategories) - i - 1])
    #and we add a generalized sheet that will hold all the data
    newWB.sheets.add("General")

    #here we go through the original array and find the values that we want to display
    #and we append them to the modified array
    #we also set the condition to find where the dividing factor is that is going to be used to find the correct sheet to insert the data into
    for i in range(len(originalArray)):
        modifiedArray.append([])
        for j in range(len(convertingSettings)):
            modifiedArray[i].append(originalArray[i][convertingSettings[j]])
            if(indexes[convertingSettings[j]] == dividingSettings):
                dividingIndex = j
    
    #we create a dictionary to hold all the seperated data that we want to display into it's prespective named sheets
    finalArrays = {}
    #we create arrays into the dictionary that are keyed by the dividing factor
    for i in dividingCategories:
        finalArrays[i] = []
    
    #we update the user of our status
    listofActions.addItem("Dividing Data into " + str(len(dividingCategories)) + " sheets")
    QtCore.QCoreApplication.processEvents() 
    #we iterate through the modified array and append every value into the general sheet alongside the headers to every sheet
    for i in range(len(modifiedArray)):
        newWB.sheets["General"].range('A' + str(i+1)).value = modifiedArray[i]
        if(i == 0):
            for x in range(len(dividingCategories)):
                newWB.sheets[dividingCategories[x]].range('A' + str(i+1)).value = modifiedArray[i]
        else:
            #if we triggered the subtype boolean earlier, we use the find function due to the cells holding the subtype being in a different format
            if(isSubtype):
                if(modifiedArray[i][dividingIndex] != None):
                    if(modifiedArray[i][dividingIndex].find('Shingle') != -1):
                        finalArrays['Shingle'].append(modifiedArray[i])
                    elif(modifiedArray[i][dividingIndex].find('Metal') != -1):
                        finalArrays['Metal'].append(modifiedArray[i])
                    elif(modifiedArray[i][dividingIndex].find('TPO') != -1):
                        finalArrays['TPO'].append(modifiedArray[i])
                    elif(modifiedArray[i][dividingIndex].find('Coating') != -1):
                        finalArrays['Coating'].append(modifiedArray[i])
            else:
                #if we didn't trigger the subtype boolean earlier, we use the index of the dividing factor to find the correct array in the dictionary
                #the reason we don't put it straight into the sheet is that if going straight into the sheet, there would be blank rows of data due to not every row being in every sheet,
                #so rows are skipped using i in the range of the modified array
                for x in range(len(dividingCategories)):
                    if(modifiedArray[i][dividingIndex] == dividingCategories[x]):
                        finalArrays[dividingCategories[x]].append(modifiedArray[i])
    
    #we update the user of our status
    listofActions.addItem("Saving Data to New File")
    QtCore.QCoreApplication.processEvents() 
    #now we iterate through each dividing cateogy we have and append the data into the correct sheet
    for i in range(len(dividingCategories)):
        for j in range(1, len(finalArrays[dividingCategories[i]])):
            newWB.sheets[dividingCategories[i]].range('A' + str(j+1)).value = finalArrays[dividingCategories[i]][j]
    
    #for readability, we correct the column with automatically to each sheet
    for i in newWB.sheets:
        i.autofit(axis='columns')
    
    #we prompt the user to save the file
    name = saveFileWindow.getSaveFileName(MainWindow, "Save File", "", "*.xlsx")
    #we save the file
    newWB.save(name[0])
    #we close the original file and the newly created file
    newWB.close()
    dfWB.close()
    #we update the user of our status
    listofActions.addItem("Finished Converting File")


class Ui_settingsWindow(object):
    def setupUi(self, settingsWindow):
        settingsWindow.setObjectName("settingsWindow")
        settingsWindow.resize(287, 385)
        self.centralwidget = QtWidgets.QWidget(settingsWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.widget = QtWidgets.QWidget(self.centralwidget)
        self.widget.setGeometry(QtCore.QRect(10, 10, 258, 303))
        self.widget.setObjectName("widget")

        self.verticalLayout = QtWidgets.QVBoxLayout(self.widget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)

        self.verticalLayout.setObjectName("verticalLayout")

        # this widget label indicates to the user what the following combo box is for
        self.sortingLabel = QtWidgets.QLabel(self.widget)
        self.sortingLabel.setObjectName("sortingLabel")
        self.sortingLabel.setText("Sort Items By")
        self.verticalLayout.addWidget(self.sortingLabel)

        # this is the combo box that allows the user to select the item to sort by
        self.sortBy = QtWidgets.QComboBox(self.widget)
        self.sortBy.setCurrentText("")
        self.sortBy.setObjectName("sortBy")
        self.verticalLayout.addWidget(self.sortBy)

        # this widget label indicates to the user what the following combo box is for
        self.divideLabel = QtWidgets.QLabel(self.widget)
        self.divideLabel.setObjectName("divideLabel")
        self.divideLabel.setText("Divide Sheets By")
        self.verticalLayout.addWidget(self.divideLabel)

        # this is the combo box that allows the user to select the item to divide by
        self.divideBy = QtWidgets.QComboBox(self.widget)
        self.divideBy.setObjectName("divideBy")
        self.verticalLayout.addWidget(self.divideBy)

        # this widget label indicates to the user what the following combo box is for
        self.orderLabel = QtWidgets.QLabel(self.widget)
        self.orderLabel.setObjectName("orderLabel")
        self.orderLabel.setText("Sort by Ascending or Descending Order")
        self.verticalLayout.addWidget(self.orderLabel)

        # this is the combo box that allows the user to select the order to sort by
        # ascending or descending being a-z or z-a
        self.ascendDescend = QtWidgets.QComboBox(self.widget)
        self.ascendDescend.setObjectName("ascendDescend")
        self.verticalLayout.addWidget(self.ascendDescend)

        # this widget label indicates to the user what the following list widget is for
        self.itemsLabel = QtWidgets.QLabel(self.widget)
        self.itemsLabel.setObjectName("itemsLabel")
        self.itemsLabel.setText("Select the items you would like to convert")

        # this is the list widget that allows the user to select the items to convert
        self.verticalLayout.addWidget(self.itemsLabel)
        self.itemsShown = QtWidgets.QListWidget(self.widget)
        self.itemsShown.setObjectName("itemsShown")
        self.verticalLayout.addWidget(self.itemsShown)
        settingsWindow.setCentralWidget(self.centralwidget)

        self.menubar = QtWidgets.QMenuBar(settingsWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 278, 21))
        self.menubar.setObjectName("menubar")

        settingsWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(settingsWindow)
        self.statusbar.setObjectName("statusbar")
        settingsWindow.setStatusBar(self.statusbar)

        # since our settingsWindow is an instance of the Ui_settingsWindow class, we set the closeEvent of the settingsWindow to the closeEvent function in the Ui_settingsWindow class
        settingsWindow.closeEvent = self.closeEvent
        # this sets the currently saved settings in the config.json
        self.getSettings()

        self.retranslateUi(settingsWindow)
        QtCore.QMetaObject.connectSlotsByName(settingsWindow)

    def retranslateUi(self, settingsWindow):
        _translate = QtCore.QCoreApplication.translate
        settingsWindow.setWindowTitle(
            _translate("settingsWindow", "MainWindow"))

    # this function is called to when the user first opens the interface or when they access the settings window
    def getSettings(self):
        # this sets the currently saved settings in the config.json
        # the following for loop sets the values of the combo boxes and list widget to the saved settings
        for i in range(len(indexes)):
            # here we receive the settings we use to select what items we retrieve from the original dataforma datasheet and have it converted
            # into the export
            # if the settings are true, we add the index to the list widget checked
            if(settings['Convert Settings'][0][indexes[i]]):
                item = QtWidgets.QListWidgetItem()
                item.setText(indexes[i])
                item.setCheckState(QtCore.Qt.Checked)
                self.itemsShown.addItem(item)
            # if the settings are false, we add the index to the list widget unchecked
            else:
                item = QtWidgets.QListWidgetItem()
                item.setText(indexes[i])
                item.setCheckState(QtCore.Qt.Unchecked)
                self.itemsShown.addItem(item)
            # this sets the sorting combo box to the saved settings
            # if the found settings are false, we simply add them to the list in the combo box
            if(not settings['Sorting Settings'][0][indexes[i]]):
                self.sortBy.addItem(indexes[i])
            # however, if the settings found are true, we add them to the combo box and set the combo box index to this current index
            # as the default value to sort by
            else:
                self.sortBy.addItem(indexes[i])
                self.sortBy.setCurrentIndex(i)
        # this sets the order combo box to ascending or descending
        self.ascendDescend.addItem("Ascending")
        self.ascendDescend.addItem("Descending")
        # if the saved settings are true, we set the combo box index to 0 wher it is ascending
        if(settings['Order Settings'][0]["Ascending"]):
            self.ascendDescend.setCurrentIndex(0)
        # if the saved settings are false, we set the combo box index to 1 where it is descending
        else:
            self.ascendDescend.setCurrentIndex(1)

        for i in range(len(dividingIndexes)):
            # this sets the divide combo box to the saved settings
            # if the found settings are false, we simply add them to the list in the combo box
            if(not settings['Divide Settings'][0][dividingIndexes[i]]):
                self.divideBy.addItem(dividingIndexes[i])
            # however, if the settings found are true, we add them to the combo box and set the combo box index to this current index
            # as the default value to divide by
            else:
                self.divideBy.addItem(dividingIndexes[i])
                self.divideBy.setCurrentIndex(i)

    # this function is called when the user clicks the close button on the settings window

    def saveSettings(self):
        # we iterate throughout the entire listed indexes within the widget and combo boxes to save the settings
        for i in range(self.itemsShown.count()):
            # if the item is checked, we set the settings to true
            if(self.itemsShown.item(i).checkState() == QtCore.Qt.Checked):
                settings['Convert Settings'][0][indexes[i]] = True
            # if the item is unchecked, we set the settings to false
            else:
                settings['Convert Settings'][0][indexes[i]] = False
            # we find if the current index is the same as the selected combo box index for sorting
            # if it is, we set the settings to true to be the default index to sort by next time the user opens the settings window
            if(indexes[i] == self.sortBy.currentText()):
                settings['Sorting Settings'][0][indexes[i]] = True
            # if it is not, we set the settings to false to not be the default index to sort by next time the user opens the settings window
            else:
                settings['Sorting Settings'][0][indexes[i]] = False

        for i in range(self.divideBy.count()):
            # we find if the current index is the same as the selected combo box index for dividing
            # if it is, we set the settings to true to be the default index to divide by next time the user opens the settings window
            if(dividingIndexes[i] == self.divideBy.currentText()):
                settings['Divide Settings'][0][dividingIndexes[i]] = True
            # if it is not, we set the settings to false to not be the default index to divide by next time the user opens the settings window
            else:
                settings['Divide Settings'][0][dividingIndexes[i]] = False

        # if the user selects ascending, we set the settings to true and false to the other option
        if(self.ascendDescend.currentIndex() == 0):
            settings['Order Settings'][0]["Ascending"] = True
            settings['Order Settings'][0]["Descending"] = False
        # if the user selects descending, we set the settings to false and true to the other option
        else:
            settings['Order Settings'][0]["Ascending"] = False
            settings['Order Settings'][0]["Descending"] = True
        # we save the settings to the config.json
        with open('config.json', 'w') as outfile:
            json.dump(settings, outfile, indent=2)

    # this function is called when the user closes the settings window
    def closeEvent(self, event):
        # we call the save settings function to save the settings
        self.saveSettings()
        # we close the settings window
        event.accept()


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.resize(280, 400)

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("MVR Dataforma Converter")

        self.splitter = QtWidgets.QSplitter(self.centralwidget)
        self.splitter.setGeometry(QtCore.QRect(50, 20, 181, 141))
        self.splitter.setOrientation(QtCore.Qt.Vertical)
        self.splitter.setObjectName("splitter")

        self.splitter_2 = QtWidgets.QSplitter(self.splitter)
        self.splitter_2.setOrientation(QtCore.Qt.Vertical)
        self.splitter_2.setObjectName("splitter_2")

        self.selectButton = QtWidgets.QPushButton(self.splitter_2)
        self.selectButton.setToolTip("")
        self.selectButton.setObjectName("selectButton")

        self.convertButton = QtWidgets.QPushButton(self.splitter_2)
        self.convertButton.setToolTip("")
        self.convertButton.setObjectName("convertButton")

        self.settingsButton = QtWidgets.QPushButton(self.splitter_2)
        self.settingsButton.setToolTip("")
        self.settingsButton.setObjectName("settingsButton")
        MainWindow.setCentralWidget(self.centralwidget)

        self.actionsDone = QtWidgets.QListWidget(self.centralwidget)
        self.actionsDone.setGeometry(QtCore.QRect(10, 180, 256, 192))

        self.actionsDone.setObjectName("actionsDone")

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.selectButton.clicked.connect(lambda: self.clicked("Select"))
        self.convertButton.clicked.connect(lambda: self.clicked("Convert"))
        self.settingsButton.clicked.connect(lambda: self.clicked("Settings"))

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate(
            "MainWindow", "Dataforma Converter"))
        self.selectButton.setStatusTip(_translate(
            "MainWindow", "Browse and select desired CSV file"))
        self.selectButton.setText(_translate("MainWindow", "Select"))
        self.convertButton.setStatusTip(_translate(
            "MainWindow", "Converts selected CSV file to formatted XLSX"))
        self.convertButton.setText(_translate("MainWindow", "Convert"))
        self.settingsButton.setStatusTip(_translate(
            "MainWindow", "Access your format settings "))
        self.settingsButton.setText(_translate("MainWindow", "Settings"))

    # this function is called when the user clicks on any of the buttons
    # depending on the text of the button, the function will do different things
    def clicked(self, text):
        # if the user clicks on the select button, we call the select function
        # where the user is prompted to select a csv file in their directories
        if(text == "Select"):
            global selectedFile
            selectedFile = QFileDialog.getOpenFileName(
                MainWindow, 'Open file', 'c:\\', "Comma Seperated Values (*.csv)")
            # if the user selects a file, we add the file to the list of actions done
            if(selectedFile[0] != ""):
                self.actionsDone.addItem("Selected file: " + selectedFile[0])
            else:
                self.actionsDone.addItem("No file selected")

        # if the user clicks on the convert button, we call the convert function
        if(text == "Convert"):
            self.actionsDone.addItem("Converting selected file")
            # if the user has not selected a file, we prompt them to select a file
            # otherwise we convert to the settings selected from the config json or their current modified settings
            if(selectedFile != "" or selectedFile != None):
                convert(selectedFile[0], settings, self.actionsDone)
            else:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText("Please select a file to convert")
                msg.setWindowTitle("No File Selected")
                msg.exec_()
        # if the user clicks on the settings button, we call the settings function
        # where the user can modify their settings
        if(text == "Settings"):
            self.actionsDone.addItem("Settings Opened")
            settingsWindow.show()


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    settingsWindow = QtWidgets.QMainWindow()

    settingui = Ui_settingsWindow()
    settingui.setupUi(settingsWindow)


    saveFileWindow = QFileDialog()
    saveFileWindow.setFileMode(QFileDialog.AnyFile)
    saveFileWindow.setAcceptMode(QFileDialog.AcceptSave)
    saveFileWindow.setNameFilter("Excel Files (*.xlsx)")
    saveFileWindow.setWindowTitle("Save File")
    saveFileWindow.setDirectory(os.getcwd())

    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    # we check if this is our first launch to set the default settings for the prespective user
    if(settings['First Launch']):
        settingsWindow.show()
        settings['First Launch'] = False
    sys.exit(app.exec_())
